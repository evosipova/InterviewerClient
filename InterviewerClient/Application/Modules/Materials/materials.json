{
    "materials": [
        {
            "id": 1,
            "title": "Проблема Retain Cycle",
            "subtitle": "Как возникает утечка памяти и как её избежать в Swift",
            "isLiked": false,
            "level": "junior",
            "content": "Одной из частых проблем управления памятью в iOS-разработке является Retain Cycle — цикл сильных ссылок между объектами.\n\nКогда объект A хранит сильную ссылку на объект B, а B — на A, создаётся замкнутая цепочка, из-за которой объекты не освобождаются системой даже после завершения своей работы. Это приводит к утечкам памяти (memory leaks).\n\nПростой пример:\n\n```swift\nclass A {\n    var b: B?\n}\n\nclass B {\n    var a: A?\n}\n\nlet a = A()\nlet b = B()\na.b = b   // A удерживает B\nb.a = a   // B удерживает A\n```\n\nВ этом примере оба объекта удерживают друг друга, и ни один не будет деинициализирован. Это и есть retain cycle.\n\nЧтобы разорвать цикл, используется слабая ссылка (weak) или некопируемая ссылка (unowned):\n\n```swift\nclass B {\n    weak var a: A?\n}\n```\n\nСлабая ссылка (`weak`) не увеличивает счётчик ссылок. Такие ссылки всегда должны быть optional. Когда объект, на который ссылается `weak`-ссылка, уничтожается, ссылка автоматически обнуляется.\n\nЕсли вы точно уверены, что объект всегда будет существовать, и не хотите использовать optional, можно применить `unowned`, но при этом ответственность за корректность существования объекта ложится на разработчика.\n\nВажно понимать: Retain Cycle может возникать не только между двумя объектами, но и, например, в замыканиях:\n\n```swift\nclass SomeViewController: UIViewController {\n    var onUpdate: (() -> Void)?\n\n    func setup() {\n        onUpdate = {\n            self.doSomething() // self захватывается в замыкании\n        }\n    }\n}\n```\n\nЧтобы избежать retain cycle в замыканиях, используйте захват [weak self] или [unowned self]:\n\n```swift\nonUpdate = { [weak self] in\n    self?.doSomething()\n}\n```"
        },
        {
            "id": 2,
            "title": "NSOperation или Grand Central Dispatch",
            "subtitle": "Когда выбирать GCD, а когда — NSOperation",
            "isLiked": false,
            "level": "midle",
            "content": "Вопрос о том, что выбрать — Grand Central Dispatch или NSOperation — часто возникает в контексте асинхронного программирования в iOS. Оба инструмента позволяют выполнять код параллельно, но они предназначены для разных уровней контроля и сложности задач.\n\nGCD — это низкоуровневый API на языке C, обеспечивающий эффективное планирование задач. Он предоставляет лаконичный синтаксис и используется напрямую через DispatchQueue. Запуск задач с помощью GCD очень прост, например:\n\n```swift\nDispatchQueue.global().async {\n    print(\"Фоновая задача\")\n}\n```\n\nGCD идеально подходит для случаев, когда требуется быстро выполнить задачу в фоновом потоке или вернуться на главный поток для обновления пользовательского интерфейса. Однако у GCD есть недостаток — вы теряете контроль над задачей сразу после её запуска. Нельзя её отменить, приостановить или установить зависимости.\n\nNSOperation и NSOperationQueue — это объектно-ориентированная обёртка над GCD. Используя NSOperation, разработчик может не только отправлять задачи в очередь, но и управлять их выполнением: отменять, приостанавливать, задавать зависимости между операциями. Пример создания и запуска операции:\n\n```swift\nlet operation = BlockOperation {\n    print(\"Операция выполняется\")\n}\nlet queue = OperationQueue()\nqueue.addOperation(operation)\n```\n\nЭто даёт большую гибкость. Например, вы можете задать, чтобы одна операция выполнялась только после завершения другой, или ограничить количество одновременно выполняемых операций.\n\nЕсли перед вами стоит задача, где необходима простота, высокая производительность и отсутствие сложных зависимостей между задачами — выбирайте GCD. Если же требуется детальный контроль над очередями и операциями, лучше использовать NSOperation. Оба инструмента тесно связаны, но решают задачи разного уровня."
        },
        {
            "id": 3,
            "title": "Value Type и Reference Type",
            "subtitle": "В чём разница между значениями и ссылками в Swift",
            "isLiked": false,
            "level": "junior",
            "content": "Swift разделяет типы на две категории: значимые и ссылочные. Это фундаментальное различие, которое определяет поведение переменных при передаче, копировании и хранении в памяти.\n\nЗначимые типы (Value Types) создают копию своих данных при передаче в функцию или присваивании другой переменной. Таким образом, изменения в копии не затрагивают оригинал. Примерами значимых типов являются Int, Double, String, Array, Struct и Enum. Пример:\n\n```swift\nstruct Point {\n    var x: Int\n    var y: Int\n}\n\nvar a = Point(x: 0, y: 0)\nvar b = a\nb.x = 10\nprint(a.x) // 0\n```\n\nВ этом примере переменная `b` получает копию структуры `a`, а не ссылку на неё. Изменение значения `x` в `b` никак не влияет на `a`.\n\nСсылочные типы (Reference Types) работают иначе. При передаче или присваивании сохраняется ссылка на один и тот же экземпляр. Изменения через одну переменную отражаются везде, где используется ссылка на этот экземпляр. Примером ссылочного типа является Class:\n\n```swift\nclass PointClass {\n    var x: Int = 0\n}\n\nlet a = PointClass()\nlet b = a\nb.x = 10\nprint(a.x) // 10\n```\n\nОбе переменные `a` и `b` указывают на один и тот же объект в памяти. Изменение через одну переменную отразится на другой.\n\nНа уровне хранения в памяти значимые типы обычно располагаются в стеке — это быстрая и автоматически управляемая область памяти. Ссылочные типы хранятся в куче — более гибкой, но требующей управления с помощью подсчёта ссылок (ARC).\n\nСтоит помнить, что если значимый тип вложен внутрь ссылочного, то он тоже будет храниться в куче. Это важно учитывать при проектировании моделей данных, особенно при работе с производительностью и утечками памяти.\n\nВыбор между значимым и ссылочным типом зависит от задач. Если требуется неизменяемость, копируемость и простота — выбирайте значимые типы. Если важна совместная работа с одним и тем же экземпляром — ссылочные."
        },
        {
            "id": 4,
            "title": "Копирование массива и структуры",
            "subtitle": "Как работает Copy-on-Write и чем отличается глубокое копирование от поверхностного",
            "isLiked": false,
            "level": "senior",
            "content": "Вопрос о различиях между копированием массива и структуры в Swift тесно связан с механизмом Copy-on-Write. Этот механизм позволяет оптимизировать использование памяти при работе с коллекциями, но работает не во всех случаях. Разберёмся, как именно он функционирует и почему важно понимать разницу между глубоким и поверхностным копированием.\n\nCopy-on-Write применяется в Swift ко встроенным типам коллекций, таким как массивы и словари. Когда переменная получает значение массива, она не создаёт немедленную копию данных. Вместо этого обе переменные указывают на одну и ту же область памяти до момента, пока не произойдёт попытка изменения одной из них. Тогда создаётся отдельная копия, и переменные начинают указывать на разные участки памяти.\n\n```swift\nvar arrayA = [1, 2, 3]\nlet arrayB = arrayA\narrayA.append(4)\n```\n\nДо добавления элемента массивы `arrayA` и `arrayB` указывают на одну и ту же память. Как только массив `arrayA` изменяется, Swift копирует его содержимое, и `arrayA` получает новую область в памяти. Это и есть реализация Copy-on-Write.\n\nС классами (Reference Type) ситуация иная. При копировании массива, содержащего экземпляры классов, новые объекты не создаются. Копируются лишь ссылки. Это называется поверхностным копированием. При изменении одного из объектов в массиве изменение будет видно и в другом массиве, так как оба указывают на один и тот же объект.\n\n```swift\nclass Contact {\n    var name: String\n    init(name: String) { self.name = name }\n}\n\nvar arrayA = [Contact(name: \"Ivan\")]\nvar arrayB = arrayA\narrayB[0].name = \"Petr\"\nprint(arrayA[0].name) // Petr\n```\n\nОбе переменные `arrayA` и `arrayB` ссылаются на один объект, и изменения в одной отражаются в другой. Чтобы избежать этого, применяют глубокое копирование — создание полностью новых экземпляров.\n\n```swift\nclass Contact: NSCopying {\n    var name: String\n    init(name: String) { self.name = name }\n    func copy(with zone: NSZone? = nil) -> Any {\n        Contact(name: name)\n    }\n}\n\nextension Array where Element: NSCopying {\n    var copy: [Element] {\n        map { $0.copy(with: nil) as! Element }\n    }\n}\n\nvar arrayA = [Contact(name: \"Ivan\")]\nvar arrayB = arrayA.copy\narrayB[0].name = \"Petr\"\nprint(arrayA[0].name) // Ivan\nprint(arrayB[0].name) // Petr\n```\n\nПри глубокем копировании создаются новые экземпляры каждого объекта, и изменения одного массива не затрагивают другой. Глубокое копирование применяется только к тем типам, которые реализуют протокол `NSCopying`.\n\nА как быть со структурами? Структуры — это типы значения. При копировании структуры создаётся новый экземпляр в памяти, даже если она используется внутри массива. Swift автоматически применяет Copy-on-Write к массивам структур, но сами структуры при передаче копируются.\n\n```swift\nstruct Contact {\n    var name: String\n}\n\nvar arrayA = [Contact(name: \"Ivan\")]\nvar arrayB = arrayA\narrayB[0].name = \"Petr\"\nprint(arrayA[0].name) // Ivan\nprint(arrayB[0].name) // Petr\n```\n\nПри изменении структуры внутри массива `arrayB` Swift создаёт новую копию, и `arrayA` остаётся неизменной. Это связано с тем, что структура — value type, и попытка изменить значение в одном из массивов вызывает полное копирование.\n\nТаким образом, понимание работы Copy-on-Write, отличий поверхностного и глубокого копирования, а также специфики типов значения и ссылок позволяет писать безопасный и эффективный код в Swift. Это критически важно на senior-уровне, где не только важен результат, но и его производительность и стабильность."
        },
        {
            "id": 5,
            "title": "Что выведется в консоль?",
            "subtitle": "Разбор порядка вывода в многопоточном коде с синхронными и асинхронными вызовами",
            "isLiked": false,
            "level": "middle",
            "content": "Один из распространённых вопросов на собеседовании по iOS — это анализ кода с многопоточностью, особенно когда сочетаются синхронные и асинхронные вызовы. Рассмотрим следующий пример:\n\n```swift\nimport Foundation\n\nfunc printMultithreading() {\n    print(\"2\")\n    DispatchQueue.global().async {\n        print(\"3\")\n        DispatchQueue.main.sync {\n            print(\"4\")\n        }\n        print(\"5\")\n    }\n    print(\"6\")\n}\n\nprint(\"1\")\nprintMultithreading()\nprint(\"7\")\n```\n\nЧтобы понять порядок вывода, нужно учитывать, как работают очереди и где происходит блокировка.\n\n1. Сначала выполняется `print(\"1\")` — главный поток.\n2. Затем вызывается `printMultithreading()`, в нём — `print(\"2\")`.\n3. Затем асинхронно запускается глобальная очередь, но пока она не начинает выполняться, выполняется следующий синхронный вызов — `print(\"6\")`.\n4. Далее выполняется `print(\"7\")`.\n5. Затем уже начинает работать глобальная очередь — `print(\"3\")`.\n6. После этого вызывается синхронный блок на главной очереди `DispatchQueue.main.sync { print(\"4\") }`, и здесь происходит Deadlock, так как мы находимся внутри глобальной очереди, но она синхронно вызывает главный поток, который уже занят.\n\nИтог: программа зависнет на `DispatchQueue.main.sync` и не завершит выполнение. При этом до зависания в консоль выведется: `1`, `2`, `6`, `7`, `3`.\n\nВажно помнить: **никогда не вызывайте `DispatchQueue.main.sync` из других потоков, если вы не уверены, что главный поток свободен**."
        },
        {
            "id": 6,
            "title": "Приоритеты Quality of Service",
            "subtitle": "Как выбрать подходящий уровень качества обслуживания в многопоточной задаче",
            "isLiked": false,
            "level": "middle",
            "content": "QoS (Quality of Service) — это механизм, определяющий приоритет выполнения задач в очередях GCD. Он позволяет системе понимать, насколько важно выполнение данной задачи, и выделять ресурсы соответственно.\n\nСуществует несколько уровней QoS:\n\n- `.userInteractive` — максимальный приоритет, используется для анимаций, нажатий, обновлений UI. Должен быть завершён мгновенно.\n- `.userInitiated` — задачи, инициированные пользователем и требующие немедленного завершения. Например, загрузка данных после нажатия кнопки.\n- `.utility` — фоновая работа с низким приоритетом, например, загрузка файла с прогрессом.\n- `.background` — самый низкий приоритет. Подходит для резервного копирования, аналитики.\n- `.default` — стандартный приоритет, применяется по умолчанию.\n- `.unspecified` — используется системой для выбора приоритета.\n\nПример использования:\n\n```swift\nlet queue = DispatchQueue.global(qos: .userInitiated)\nqueue.async {\n    print(\"Важная задача\")\n}\n```\n\nВыбор QoS влияет на скорость выполнения задачи, но не гарантирует её порядок. Важно правильно определять приоритет: не стоит использовать `.userInteractive` без необходимости, так как это может замедлить UI."
        },
        {
            "id": 7,
            "title": "Что такое defer в Swift?",
            "subtitle": "Как работает оператор defer и зачем он нужен",
            "isLiked": false,
            "level": "junior",
            "content": "Оператор `defer` в Swift позволяет отложить выполнение блока кода до момента выхода из текущей области видимости. Это особенно полезно, когда нужно гарантированно выполнить финализацию или очистку ресурсов, независимо от того, как завершилось выполнение функции — успешно или с ошибкой.\n\nРассмотрим базовый пример:\n\n```swift\nfunc test() {\n    print(\"Start\")\n    defer {\n        print(\"Deferred\")\n    }\n    print(\"End\")\n}\n\ntest()\n```\n\nРезультат выполнения:\n```\nStart\nEnd\nDeferred\n```\n\nКак видно, `defer` выполняется в самом конце, перед выходом из функции. Вы можете использовать несколько `defer`-блоков — они будут вызваны в обратном порядке (LIFO):\n\n```swift\nfunc multipleDefers() {\n    defer { print(\"First\") }\n    defer { print(\"Second\") }\n    print(\"Body\")\n}\n\nmultipleDefers()\n```\n\nРезультат:\n```\nBody\nSecond\nFirst\n```\n\nПрименение `defer` полезно, например, при работе с файлами или сетевыми соединениями:\n\n```swift\nfunc readFile() {\n    let file = open(\"data.txt\")\n    defer { close(file) }\n    // работа с файлом\n}\n```\n\nТаким образом, `defer` гарантирует, что `close(file)` вызовется при любом исходе. Это делает код более безопасным и читаемым, особенно в функциях с множественными точками выхода."
        },
        {
            "id": 8,
            "title": "Optional и Optional Binding",
            "subtitle": "Что такое optional и как безопасно извлекать значения",
            "isLiked": false,
            "level": "junior",
            "content": "Optional — это специальный тип в Swift, который позволяет переменной содержать либо значение, либо `nil`. Он обозначается знаком `?` после типа. Например:\n\n```swift\nvar name: String? = \"Alice\"\n```\n\nЗдесь переменная `name` может содержать строку или быть пустой (nil). Если вы попытаетесь обратиться к значению напрямую:\n\n```swift\nprint(name.count) // Ошибка\n```\n\nВы получите ошибку, потому что `name` — это `Optional`, а не `String`. Чтобы использовать значение, его нужно извлечь (unwrap). Один из способов — использовать `if let`:\n\n```swift\nif let actualName = name {\n    print(actualName.count)\n} else {\n    print(\"Нет значения\")\n}\n```\n\nЭто называется Optional Binding — безопасное извлечение значения. Альтернативный способ — `guard let`, особенно полезный в функциях:\n\n```swift\nfunc greet(_ name: String?) {\n    guard let unwrapped = name else {\n        print(\"Привет, гость!\")\n        return\n    }\n    print(\"Привет, \\(unwrapped)!\")\n}\n```\n\nЕсли вы уверены, что значение точно есть, можно использовать `!`, но это может привести к крашу, если там `nil`:\n\n```swift\nlet sureName: String = name!\n```\n\nТакже часто используют `??` для указания значения по умолчанию:\n\n```swift\nlet finalName = name ?? \"Unknown\"\n```\n\nПонимание Optional и их безопасного извлечения — один из фундаментальных навыков для начинающего iOS-разработчика."
        },
        {
            "id": 9,
            "title": "Понимание замыканий в Swift",
            "subtitle": "Как работают closures и зачем они нужны",
            "isLiked": false,
            "level": "junior",
            "content": "Замыкания (closures) в Swift — это блоки кода, которые можно сохранять, передавать и вызывать позже. Они похожи на функции, но часто используются как значения. Пример простого замыкания:\n\n```swift\nlet greet = { print(\"Привет, мир!\") }\ngreet()\n```\n\nЗамыкания могут принимать параметры и возвращать значения:\n\n```swift\nlet square: (Int) -> Int = { number in\n    return number * number\n}\nprint(square(5)) // 25\n```\n\nВы можете передавать замыкания как параметры в функции:\n\n```swift\nfunc execute(action: () -> Void) {\n    action()\n}\nexecute { print(\"Вызвано из замыкания\") }\n```\n\nЗамыкания захватывают переменные из окружающего контекста:\n\n```swift\nvar counter = 0\nlet increment = {\n    counter += 1\n}\n\nincrement()\nprint(counter) // 1\n```\n\nВажно помнить о возможном retain cycle при использовании `self` внутри замыкания. Чтобы избежать утечек памяти:\n\n```swift\n[weak self] in self?.doSomething()\n```\n\nЗамыкания — основа для API вроде анимаций, колбэков, работы с коллекциями и многопоточности. Их понимание критически важно для любого iOS-разработчика."
        },
        {
            "id": 10,
            "title": "Функции высшего порядка",
            "subtitle": "Как использовать map, filter и reduce в Swift",
            "isLiked": false,
            "level": "junior",
            "content": "Функции высшего порядка — это функции, которые принимают другие функции как аргументы или возвращают функции. В Swift они позволяют удобно и компактно обрабатывать коллекции. Три самые популярные:\n\n `map`\nСоздаёт новый массив, преобразуя каждый элемент:\n\n```swift\nlet numbers = [1, 2, 3]\nlet squared = numbers.map { $0 * $0 }\nprint(squared) // [1, 4, 9]\n```\n\n `filter`\nОтбирает элементы, соответствующие условию:\n\n```swift\nlet even = numbers.filter { $0 % 2 == 0 }\nprint(even) // [2]\n```\n\n `reduce`\nПреобразует массив в одно значение, например, сумму:\n\n```swift\nlet sum = numbers.reduce(0) { $0 + $1 }\nprint(sum) // 6\n```\n\nМожно комбинировать:\n\n```swift\nlet result = numbers\n    .filter { $0 > 1 }\n    .map { $0 * 10 }\nprint(result) // [20, 30]\n```\n\nПонимание этих функций улучшает читаемость кода и позволяет эффективно обрабатывать массивы без циклов."
        },
        {
            "id": 11,
            "title": "Разница между struct и class",
            "subtitle": "Что выбрать в Swift — структуру или класс",
            "isLiked": false,
            "level": "junior",
            "content": "В Swift у разработчика есть два основных инструмента для создания собственных типов — структуры (`struct`) и классы (`class`).\n\nОсновное различие — в семантике: структуры — типы значения (value types), а классы — ссылочные типы (reference types).\n\n Struct (значимый тип)\n\n```swift\nstruct User {\n    var name: String\n}\nvar u1 = User(name: \"Alice\")\nvar u2 = u1\nu2.name = \"Bob\"\nprint(u1.name) // Alice\n```\n\n`u1` и `u2` — это копии. Изменение одного не влияет на другой.\n\n Class (ссылочный тип)\n\n```swift\nclass User {\n    var name: String\n    init(name: String) { self.name = name }\n}\nlet u1 = User(name: \"Alice\")\nlet u2 = u1\nu2.name = \"Bob\"\nprint(u1.name) // Bob\n```\n\nОбе переменные ссылаются на один объект.\n\n Когда использовать `struct`:\n- данные не должны изменяться совместно;\n- важно предсказуемое поведение при передаче;\n- нужна лучшая производительность.\n\n Когда использовать `class`:\n- нужно наследование;\n- требуется один объект в нескольких местах.\n\nПравильный выбор влияет на читаемость, надёжность и производительность кода."
        },
        {
            "id": 12,
            "title": "Enum в Swift",
            "subtitle": "Как использовать перечисления с ассоциированными значениями и raw-типами",
            "isLiked": false,
            "level": "junior",
            "content": "Перечисления (`enum`) в Swift — мощный инструмент для описания фиксированного набора вариантов. Они могут иметь raw-значения или ассоциированные значения.\n\n Raw values:\n\n```swift\nenum Direction: String {\n    case north = \"N\"\n    case south = \"S\"\n}\n\nlet d = Direction.north\nprint(d.rawValue) // \"N\"\n```\n\n Ассоциированные значения:\n\n```swift\nenum Media {\n    case image(name: String)\n    case video(url: String)\n}\n\nlet file = Media.image(name: \"photo.png\")\n```\n\n Switch с enum:\n\n```swift\nswitch file {\ncase .image(let name):\n    print(\"Image named \\(name)\")\ncase .video(let url):\n    print(\"Video at \\(url)\")\n}\n```\n\nEnum позволяют выразительно моделировать состояния, события, ошибки и многое другое. С ними удобно строить `state machines`, использовать `Optionals`, `Result` и паттерн `enum with data`."
        },
        {
            "id": 13,
            "title": "Основы протоколов",
            "subtitle": "Зачем нужны протоколы и как они применяются в Swift",
            "isLiked": false,
            "level": "junior",
            "content": "Протоколы (`protocol`) в Swift описывают интерфейс — набор свойств и методов, которые должны быть реализованы. Они позволяют строить гибкие и масштабируемые архитектуры.\n\n Пример:\n\n```swift\nprotocol Drawable {\n    func draw()\n}\n\nstruct Circle: Drawable {\n    func draw() {\n        print(\"Рисуем круг\")\n    }\n}\n```\n\n Протокол как тип:\n\n```swift\nlet item: Drawable = Circle()\nitem.draw()\n```\n\nВы можете комбинировать несколько протоколов, использовать наследование протоколов, или добавлять default-реализации через расширения:\n\n```swift\nextension Drawable {\n    func draw() {\n        print(\"По умолчанию рисуем что-то\")\n    }\n}\n```\n\nПротоколы лежат в основе многих фреймворков Apple (например, `UITableViewDataSource`, `Codable`, `Equatable`) и позволяют писать обобщённый (generic) и чистый код.\n\nДля джуна важно понять, что протокол — это не только контракт, но и способ достичь композиции вместо наследования."
        },
        {
            "id": 14,
            "title": "Memory Management и ARC",
            "subtitle": "Как работает автоматическое управление памятью в Swift",
            "isLiked": false,
            "level": "middle",
            "content": "Swift использует ARC (Automatic Reference Counting) для автоматического управления памятью. Каждый объект класса имеет счётчик ссылок. Когда количество сильных ссылок на объект становится 0, он удаляется из памяти.\n\n```swift\nclass Person {\n    let name: String\n    init(name: String) { self.name = name }\n    deinit { print(\"\\(name) освобождён\") }\n}\n\nvar p: Person? = Person(name: \"Anna\")\np = nil\n```\n\nОднако если возникает retain cycle, объекты никогда не освобождаются. ARC не срабатывает, потому что ссылки продолжают существовать:\n\n```swift\nclass A {\n    var b: B?\n}\n\nclass B {\n    var a: A?\n}\n```\n\nЧтобы устранить такие циклы, используют `weak` и `unowned`. `weak` ссылки автоматически обнуляются, `unowned` — нет, но предполагают, что объект точно жив.\n\nВажно понимать, где и когда освобождаются объекты. Правильное использование ARC позволяет избежать утечек и гарантирует стабильность приложения."
        },
        {
            "id": 15,
            "title": "DispatchGroup и синхронизация задач",
            "subtitle": "Как дождаться завершения нескольких асинхронных операций",
            "isLiked": false,
            "level": "middle",
            "content": "DispatchGroup — это механизм GCD, позволяющий отслеживать завершение группы асинхронных задач. Это полезно, когда вы хотите начать что-то только после завершения нескольких операций.\n\n```swift\nlet group = DispatchGroup()\n\nfor i in 1...3 {\n    group.enter()\n    DispatchQueue.global().async {\n        print(\"Задача \\(i)\")\n        sleep(1)\n        group.leave()\n    }\n}\n\ngroup.notify(queue: .main) {\n    print(\"Все задачи завершены\")\n}\n```\n\n`enter()` сообщает о начале работы, `leave()` — об окончании. `notify` вызывается, когда все `.enter` сбалансированы `leave`.\n\nТакже можно использовать `group.wait()` для синхронного ожидания завершения. Однако в большинстве случаев лучше использовать `notify`, чтобы избежать блокировок потока."
        },
        {
            "id": 16,
            "title": "Асинхронные функции и async/await",
            "subtitle": "Как упростить асинхронный код в Swift",
            "isLiked": false,
            "level": "middle",
            "content": "Начиная с Swift 5.5, появилась возможность писать асинхронный код с помощью `async/await`. Это делает код более линейным и читаемым по сравнению с колбэками или замыканиями.\n\n```swift\nfunc fetchData() async -> String {\n    return \"Данные\"\n}\n\nTask {\n    let result = await fetchData()\n    print(result)\n}\n```\n\n`async`-функции могут вызываться только из других `async`-функций или через `Task`. Если функция может выбрасывать ошибку, используется `async throws`, а вызов — через `try await`.\n\n```swift\nfunc load() async throws -> String {\n    throw URLError(.badServerResponse)\n}\n\nTask {\n    do {\n        let text = try await load()\n        print(text)\n    } catch {\n        print(\"Ошибка: \\(error)\")\n    }\n}\n```\n\nПонимание `async/await` важно для работы с API, сетевыми запросами и долгими операциями без блокировки UI."
        },
        {
            "id": 17,
            "title": "Dependency Injection в iOS",
            "subtitle": "Как сделать код тестируемым и слабосвязанным",
            "isLiked": false,
            "level": "middle",
            "content": "Dependency Injection (DI) — это паттерн, при котором зависимости объекта передаются извне. Это упрощает тестирование и повышает модульность.\n\nЕсть несколько способов внедрения зависимостей:\n\n1. Инициализатор:\n```swift\nclass ViewModel {\n    let service: APIService\n    init(service: APIService) {\n        self.service = service\n    }\n}\n```\n\n2. Свойство:\n```swift\nclass Controller {\n    var viewModel: ViewModel!\n}\n```\n\n3. Service Locator (нежелателен):\n```swift\nlet service = Container.shared.resolve(APIService.self)\n```\n\nDI делает компоненты независимыми, их можно подменять заглушками в тестах:\n```swift\nclass MockAPI: APIService { ... }\n```\n\nИспользуйте DI, если хотите масштабируемое и проверяемое приложение."
        },
        {
            "id": 18,
            "title": "Протоколы и абстракции",
            "subtitle": "Как строить гибкую архитектуру с использованием протоколов",
            "isLiked": false,
            "level": "middle",
            "content": "Протоколы позволяют строить абстракции и работать с зависимостями через интерфейсы, а не конкретные реализации. Это основа протокольно-ориентированного программирования в Swift.\n\n```swift\nprotocol NetworkService {\n    func request(endpoint: String) async throws -> Data\n}\n\nclass APIClient: NetworkService {\n    func request(endpoint: String) async throws -> Data {\n        // реализация\n    }\n}\n```\n\nВы можете использовать протоколы как тип:\n```swift\nlet service: NetworkService = APIClient()\n```\n\nЭто даёт возможность:\n- Подменять реализации (например, мок-сервисы в тестах)\n- Строить слои архитектуры (ViewModel не знает об APIClient)\n\n```swift\nclass ViewModel {\n    let service: NetworkService\n    init(service: NetworkService) {\n        self.service = service\n    }\n}\n```\n\nПонимание протоколов как абстракций помогает создавать масштабируемый, читаемый и тестируемый код."
        },
        {
            "id": 19,
            "title": "ARC, Unowned и утечки в замыканиях",
            "subtitle": "Глубокий анализ поведения Automatic Reference Counting в контексте замыканий",
            "isLiked": false,
            "level": "senior",
            "content": "Automatic Reference Counting (ARC) в Swift работает автоматически, управляя временем жизни объектов, но при этом может создавать сложные для отладки сценарии. Особенно опасными являются retain cycle, возникающие при захвате `self` в замыканиях, которые часто используются при работе с UI, анимациями или асинхронными вызовами.\n\nРассмотрим следующую ситуацию:\n\n```swift\nclass ImageLoader {\n    var onLoad: (() -> Void)?\n\n    func load() {\n        onLoad = {\n            self.handleCompletion()\n        }\n    }\n\n    func handleCompletion() {\n        print(\"Загрузка завершена\")\n    }\n}\n```\n\nВ данном случае `self` захватывается замыканием, которое хранится в свойстве `onLoad`, таким образом создавая retain cycle. Чтобы избежать этого, используется `weak` или `unowned` захват:\n\n```swift\nonLoad = { [weak self] in\n    self?.handleCompletion()\n}\n```\n\nРазница между `weak` и `unowned` критична. `weak` создаёт опциональную ссылку, которая становится `nil`, если объект освобождён. `unowned` — не опциональный, и если объект уже освобождён, произойдёт краш. Поэтому `unowned` безопасен только там, где вы уверены, что объект будет жить дольше замыкания. На senior-уровне важно не просто избегать retain cycle, но и понимать, где безопасно использовать `unowned`, чтобы избежать лишней опциональности и улучшить производительность."
        },
        {
            "id": 20,
            "title": "Concurrency",
            "subtitle": "Как безопасно работать с асинхронным кодом в Swift",
            "isLiked": false,
            "level": "senior",
            "content": "Swift Concurrency с приходом `async/await` упростила асинхронное программирование, но не избавила от проблем многопоточности. Race conditions и несинхронизированный доступ к памяти остаются источниками багов.\n\nActors в Swift позволяют гарантировать, что доступ к состоянию объекта происходит безопасно:\n\n```swift\nactor Counter {\n    private var value = 0\n\n    func increment() {\n        value += 1\n    }\n\n    func get() -> Int {\n        value\n    }\n}\n```\n\nВсё, что происходит внутри `actor`, сериализуется, предотвращая одновременный доступ. Но важно помнить, что обращение к `actor` всегда асинхронное:\n\n```swift\nawait counter.increment()\n```\n\nЕсли необходимо обращаться к состоянию из главного потока (например, при обновлении UI), следует использовать `@MainActor`:\n\n```swift\n@MainActor class ViewModel {\n    func updateUI() {\n        // безопасно обращаться к UIKit\n    }\n}\n```\n\nНа senior-уровне важно уметь разделять изоляцию состояния (`actor`) и синхронизацию с главным потоком (`@MainActor`). Также необходимо понимать, что несмотря на безопасность, акторы — не серебряная пуля: они могут снижать производительность при чрезмерном использовании и не защищают от логических ошибок в коде."
        },
        {
            "id": 21,
            "title": "Понимание Memory Graph и инструментов Instruments",
            "subtitle": "Как отлавливать утечки памяти и циклы удержания в Xcode",
            "isLiked": false,
            "level": "senior",
            "content": "Отладка утечек памяти — важнейший навык старшего разработчика. Инструменты Xcode, такие как Memory Graph и Leaks, позволяют обнаруживать retain cycle, неочевидные ссылки и объекты, которые не освобождаются.\n\nMemory Graph запускается во время отладки (Debug > View Memory Graph Hierarchy). Он показывает, какие объекты всё ещё живы в памяти и кто их удерживает. Часто можно найти цепочку: ViewController → View → Closure → ViewController.\n\nТипичные ошибки:\n- Замыкания, хранящие `self` без `[weak self]`.\n- Делегаты, объявленные как `strong`, а не `weak`.\n- Таймеры (`Timer.scheduledTimer`) без инвалидации.\n- NotificationCenter без удаления наблюдателя.\n\nПример использования `Instruments > Leaks`:\n1. Запустите приложение через Instruments.\n2. Выберите профиль `Leaks`.\n3. Воспроизведите сценарий, при котором объект должен освободиться.\n4. Проверьте, остался ли он в памяти — это и будет утечка.\n\nНа senior-уровне вы обязаны уметь читать граф удержания, отслеживать источники ссылок и освобождать ресурсы своевременно. Инструменты отладки — ваши друзья, без которых не выявить критичных утечек в больших проектах."
        },
        {
            "id": 22,
            "title": "Абстракции в Swift",
            "subtitle": "Как строить универсальные и при этом безопасные абстракции",
            "isLiked": false,
            "level": "senior",
            "content": "Протоколы с `associatedtype` позволяют создавать гибкие и обобщённые интерфейсы, но имеют ограничения. Вы не можете использовать такой протокол как конкретный тип напрямую:\n\n```swift\nprotocol DataSource {\n    associatedtype Data\n    func load() -> Data\n}\n\n// let source: DataSource — ошибка\n```\n\nЧтобы использовать их в качестве типа, применяют дженерики:\n\n```swift\nstruct AnyLoader<T: DataSource> {\n    let loader: T\n\n    func fetch() -> T.Data {\n        loader.load()\n    }\n}\n```\n\nВ iOS 13+ появился `opaque type` (`some`), позволяющий возвращать конкретную, но скрытую реализацию:\n\n```swift\nprotocol Viewable {\n    func render() -> String\n}\n\nstruct TextView: Viewable {\n    func render() -> String { \"Text\" }\n}\n\nfunc makeView() -> some Viewable {\n    TextView()\n}\n```\n\nТаким образом, можно скрывать детали реализации, сохраняя строгую типизацию. На senior-уровне важно понимать: `some` — это не любой тип, удовлетворяющий протоколу, а конкретный, один и тот же в рамках вызова. Это помогает строить безопасные и при этом универсальные API."
        },
        {
            "id": 23,
            "title": "Оптимизация производительности списков в SwiftUI",
            "subtitle": "Как избежать лагов при работе с LazyVStack, .id() и EquatableView",
            "isLiked": false,
            "level": "senior",
            "content": "Работа с большими списками в SwiftUI требует внимательной оптимизации. Даже при использовании `LazyVStack` возможны тормоза и перерисовки при прокрутке. На старшем уровне важно понимать, что замедление часто связано не с самой прокруткой, а с повторным созданием вьюшек.\n\nЧтобы этого избежать:\n\n1. Используйте `.id()`:\n\n```swift\nForEach(items, id: \\ .id) { item in\n    RowView(item: item)\n}\n```\n\n2. Убедитесь, что `id` действительно уникален и не меняется при скролле.\n\n3. Применяйте `EquatableView`, если вьюшка не должна перерисовываться без изменений:\n\n```swift\nEquatableView(content: RowView(item: item))\n```\n\n4. Избегайте вложенных `NavigationLink` или `.sheet()` внутри `List`, если они создаются в теле каждого элемента.\n\n5. Разносите тяжелую логику за пределы тела `View`, особенно при использовании `onAppear` и `task`.\n\nПонимание причин перерисовок, особенностей diff-системы SwiftUI и работы тела `View` критично для построения отзывчивого интерфейса. Senior-разработчик должен уметь объяснить, почему возникает лаг, и предложить решение без преждевременной оптимизации."
        }

    ]
}
